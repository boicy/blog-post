0. Introduction

For the past 5 years my career has been pushing me towards an architectural concept that until recently I didn't really have a name for.  I've since realised that the term 'micro-services' applies to this concept and simply having a name for it gives me the ability to explain the costs, benefits and some of the ideas that will help you build more effective microservices.  I did not invent the concept and my first exposure was via James Lewis, a colleague at ThoughtWorks who has done a large amount of work around defining and building a knowledge base around it.  He hasn't yet written a blog post on it but has reviewed this blog series.

When James first introduced that concept to me, it was in relation to how we could suggest a client move from a Constantine two tier architecture(1) to a more flexible architecture.  James suggested that business services be built that serve a single need and can be used across the enterprise.  The idea was novel to me.

I then travelled to another client who were building a RESTful API they hoped to be able to sell.  The data needs for this project were quite complex and nobody was really sure how whether the proposed solution would support the API.  Rather than separating the complex data requirements into another service the client chose to keep all the code together in a single service.  When the proposed solution turned out to be insufficient, a large amount of rework was required throughout the codebase to change it.

The next client I worked on had four services running on simple framework in Java.  They were launched in a single JVM.  As the services did not define a bounded context for their domain(2) logic bled between the services and domain logic found its way into the shared client code.  The tightly coupled services did not provide the flexibility or scalability(3) that one would have hoped for from this type of architecture.  From here came the majority of my learnings with regard to this architecture.  It was a great effort towards micro-services, but did not quite hit the nail on the head.

It was from this project that I discovered DropWizard(4), a java framework that glued together a few awesome Java tools.  While we didn't use DropWizard for the project, when I tried to set up SimpleFramework for a Java talk, I was referred to DropWizard and immediately realised how much simpler it was to set up.  20 minutes and I had a RESTful service ready to go!    

I've now taken to DropWizard and am applying this architecture to my current project. We have 5 services that provide our core functionality and a further 3+ services that will provide support functionality (billing, reporting, audit, etc...).  Notably, our frontend service has been implemented twice (once for user testing written in Ruby and the production version written in Java) and is separated from the integration service(5) providing UI flexibility without risking integration bugs (~500 integrating parties will be in the federation). We were able to rewrite our business process service in ~2 weeks with minimal impact on the rest of the system and we are generally able to make substantial changes to the individual services with minimal impact on the rest of the system. All in all, I'd say that micro-services have given us a substantial boost to our flexibility in the face of uncertainty.  Flexibility, though, always comes at a cost.

The lessons I've learnt and the concepts we've applied over the past year are the driver behind this series of blog posts.  While I firmly believe that micro-services are a really good way to build flexible, scalable and performant systems I also accept that there are costs involved in choosing this architecture. This series will be composed of five blog posts that will cover what exactly micro-services are, what to think about when building micro-services, how REST and micro-services relate, some pragmatic thoughts around micro-services, and finally how to test micro-services effectively.

(1) An architecture composing of two tiers, usually datalayer and application layer, that are tightly coupled via remote procedure calls (SOAP, JMI, etc) and should be collapsed into a single tier.
(2) See Domain Driven Design (Eric Evans)
(3) At the time I rolled off the project
(4) http://dropwizard.codahale.com
(5) read at your own risk:  SAML Web SSO Profile 